# Решение задачи Коши для жесткой системы дифференциальных уравнений с заданной точностью

## diff.py
### Переменные
*A* --- матрица линейного уравнения ![equation](https://latex.codecogs.com/png.latex?%5Cdot%7By%7D%20%3D%20Ay)
*Y_0* --- вектор начальных данных
*x_0*, *x_1* --- начало и конец отрезка, на котором действуют функции
*N* --- количество узлов сетки
*e* --- требуемая погрешность
*k*, *k_max* --- начальное и максимальное кол-во узлов

### Функции модуля:
 * **RK(A, x_0, x_1, Y_0, N)**, **Adams(A, x_0, x_1, Y_0, N)**, **CROS(A, x_0, x_1, Y_0, N)** --- находят решение линейного дифференциального уравнения с заданным разбиением (транспонированное!)
 * **pres_RK*(A, x_0, x_1,  Y_0, k, k_max, e)*, **pres_Adams(A, x_0, x_1,  Y_0, k, k_max, e)**, **pres_CROS(A, x_0, x_1,  Y_0, k, k_max, e)** --- находят решение -//- с заданной точностью (*e*), меняя разбиение от заданного до заданного максимального (чтобы не зацикливалось). Возвращают dict (Y["value"] --- матрица-решение, Y["error"] в формате [разбиение, ошибка для разбиения]).
 * **nk(A)** --- можно найти разбиение, при котором явные методы устойчивые (теоретически)
 * **error_view(e1, e2, e3)**, **p_view(e1, e2, e3)**, **f_view(Y,x_0, x_1, num, name)** --- рисование графиков для ошибки, теоретического порядка точности и решения.
 Здесь *ei* --- Y_i["error"], т.е. массив 2xN значений [разбиение, ошибка для разбиения], *num* --- желаемые функции (например, [0,1] нарисует графики для y_0 и y_1, по умолчанию рисуется y_0), *name* --- название графика.

## тесты
чтобы запустить нужен Python 3. Решение вычисляется методами Рунге-Кутты, Адамса и Розенброка с комплексным коэффициентом, затем рисуются графики для погрешности, *p* и графики решений для каждого метода.
